# 字符串

## 题目描述

给定 N 个小写英文字符串 s_1, s_2, \ldots, s_N。这些字符串构成了一个“字典表”。

现在要做 M 次字符串查找。每次会指定一个小写英文字母 c_i。对于每个查找任务，请你在字典表中找出以 c_i 为首字母的，截止目前输出次数最少的那个字符串，并将它输出。如果同时有多个字符串满足要求，请输出字典序最小的那一个。

## 输入格式

第一行包含两个正整数 N, M，分别表示字典表大小、查找任务的数量。

接下来 N 行，每行一个仅由小写英文字母组成的字符串 s_i，描述字典表中的字符串。这些字符串互不相同。

最后 M 行，每行一个小写英文字母 c_i，依次描述每一个查询任务。

## 输出格式

共 M 行，每行一个字符串，依次表示每一个任务的查询结果。

## 样例 #1

### 样例输入 #1

```
7 6
zero
school
zoo
middle
beijing
one
soul
big
o
z
o
Operate
small
```

### 样例输出 #1

```
beijing
one
zero
one
middle
school
```

## 样例 #2

### 样例输入 #2

```
1 3
algorithm
nums
nums
nums
```

### 样例输出 #2

```
algorithm
algorithm
algorithm
```

## 样例 #3

### 样例输入 #3

```
4 6
park
yuanmingyuan
beautiful
yuan
big
o
o
p
o
big
```

### 样例输出 #3

```
beautiful
yuan
yuanmingyuan
park
yuan
beautiful
```

## 提示

对于 60% 的数据，保证 1 \le N, M \le 1000。

对于 100% 的数据，保证 1 \le N, M \le 10^5，1 \le |s_i| \le 30。

其中，|s_i| 表示字符串 s_i 的长度。

---

# d维空间的点

## 题目描述

对于两个 d 维空间的点 A = (a_1, a_2, a_3, \ldots, a_d) 、 B = (b_1, b_2, b_3, \ldots, b_d)，我们定义它们之间的 \text{dist} 为：

\text{dist}(A, B) = \sum_{i=1}^d|a_i-b_i| = |a_1 - b_1| + |a_2 - b_2| + \ldots + |a_d - b_d|

现在，给定 N 个 d 维空间的点。请从中找到两个点，使得这两点之间的 \text{dist} 最大。

## 输入格式

第一行包含两个正整数 N, d，分别表示点的个数、空间的维度。

接下来 N 行，每行包含 d 个非负整数 x_{i, 1}, x_{i, 2}, x_{i, 3}, \ldots, x_{i, d}，表示一个点在 d 维空间中的各维度坐标。

## 输出格式

一个整数，表示两点之间的最大 \text{dist} 值。

## 样例 #1

### 样例输入 #1

```
4 1
2
1
4
5
```

### 样例输出 #1

```
4
```

## 样例 #2

### 样例输入 #2

```
4 2
2 1
1 4
4 5
5 3
```

### 样例输出 #2

```
6
```

## 提示

样例#1中，(1) 与 (5) 之间的 \text{dist} 最大，为 4。

样例#2中，(2, 1) 与 (4, 5) 之间的 \text{dist} 最大，为 6。

【数据规模】

对于 40% 的数据，保证 2 ≤ N ≤ 2000。

另有 20% 的数据，保证 d = 1。

另有 16% 的数据，保证 d = 2。

对于 100% 的数据，保证 2 ≤ N ≤ 2 \times 10^5，1 ≤ d ≤ 5，0 ≤ x_{i,j} ≤ 10^6。

---

# 选数

## 题目描述

给定长度为 N 的非负整数序列 a_1, a_2, \ldots, a_N。现在请你选出其中的 M 个区间（连续子序列）。这些区间可以相互重叠，但区间长度不能大于 K。请计算，被这些区间所包含的序列元素的总和最大是多少。

注意：一个元素如果被多个区间包含，这个元素在求和时只能被计算一次。

## 输入格式

第一行包含 3 个正整数 N, M, K，分别表示序列长度、区间数量，以及每个区间的长度上限。

第二行包含 N 个非负整数 a_1, a_2, \ldots, a_N，依次描述序列的每个元素。

## 输出格式

一个整数，表示被 M 个区间所包含的序列元素的最大总和。

## 样例 #1

### 样例输入 #1

```
7 4 1
2 43 32 4 64 1 10
```

### 样例输出 #1

```
149
```

## 样例 #2

### 样例输入 #2

```
10 3 2
10 5 34 4 26 12 75 15 8 20
```

### 样例输出 #2

```
167
```

## 提示

样例#2是一个长度为 10 的序列。从中选出 3 个长度不超过 2 的区间，被区间所包含的序列元素的最大总和为 167——这些元素是 5, 34、26, 12、75, 15。

对于全部数据，保证 1 \leq N \leq 10000，1 \leq M \leq 1000, 1 \leq K \leq 150，0 \leq a_i \leq 2 \times 10^5。

其中：

- 至少 15% 的数据，保证 1 \le N, M, K \leq 100；
- 至少 50% 的数据，保证 N \le 1000；
- 至少 60% 的数据，保证 M \le 100；
- 至少 60% 的数据，保证 K \le 10。

---

# 中位数

## 题目描述

给定一个长度为 N 的正整数序列 a_1, a_2, \ldots, a_N。

现在有 M 个询问。每个询问将指定一个区间 [l_i, r_i]。对于每个询问，请你计算在子序列 a_{l_i}, a_{l_i+1}, \ldots, a_{r_i}
中一共有多少个中位数为 i 且长度为奇数的连续子序列。

简单起见，约定：

- 序列中的所有元素互不相同，且最大的元素为 N。
- 对于任意两个询问 i, j（i \ne j） ，不会出现 l_i < l_j \le r_j < r_i。

## 输入格式

第一行包含三个正整数 N, M, i，分别表示序列长度、询问个数，以及询问中的固定参数。

第二行包含 N 个正整数 a_1, a_2, \ldots, a_N，依次表示序列的每一个元素。

接下来 M 行，每行包含两个正整数 l_i, r_i，描述一个询问。

## 输出格式

共 M 行，每行包含一个非负整数，依次表示对应询问的计算结果。

## 样例 #1

### 样例输入 #1

```
6 4 3
1 5 3 2 4 6
2 5
3 5
4 6
1 3
```

### 样例输出 #1

```
3
2
0
2
```

## 提示

样例的第 1 个询问要求计算子序列 5, 3, 2, 4 中有多少中位数为 3 且长度为奇数的连续子序列。答案共有 3 个，包括子序列 5, 3, 2、3, 2, 4 和 3。

【数据规模】

对于 20% 的数据，保证 1 \le N, M \le 100。

对于 35% 的数据，保证 1 \le N, M \le 400。

对于 60% 的数据，保证 1 \le N, M \le 2000。

另有 20% 的数据，保证 M = 1。

对于 100% 的数据，保证 1 \le N, M \le 10^6，1 \le i, a_i \le N，1 \le l_i \le r_i \le N。

---

# 最短距离

## 题目描述

给定 N 个点的无向图。结点编号 1 \sim N。结点之间的边有特定的长度。此时，我们可以计算出结点 1 到结点 N 的最短距离。

例如下图中，结点 1 到结点 5 的最短距离为 44，对应的路线为 1->3->5。

![eAKnHg.png](https://s2.ax1x.com/2019/07/23/eAKnHg.png)

```cpp
1 ---(34)--- 2 ---(12)--- 4 ---(30)--- 5
|            |           /             |
|           (10) +-(16)-+              |
|            |  /                      |
+----(24)--- 3 -----------------(20)---+
```

（有人说图看不到，所以给个字符图——直接写的数字是结点，用小括号包起来的数字是边长）

现在，你可以施展 M 次魔法。每次可以选择任意一条边，并将这条边的长度缩短为原来的一半。同一条边允许被多次施展魔法，但是你不可以创建新的边。

例如上图中，若对结点1 与结点 2 之间的边施展 1 次魔法，两点之间的距离将变为 17；若施展 2 次魔法，距离则将变为 8.5。

请计算，当你拥有魔法之后，结点 1 到结点 N 的最短距离是多少。

## 输入格式

第一行包含两个整数 N, M，分别表示结点数与魔法次数。

接下来 N 行，每行 N 个非负整数 adj_{i,j}，其中第 i 行第 j 列，表示结点 i 到结点 j 的边的初始长度。特殊地，0 表示两点之间没有边直接相连。

## 输出格式

一个实数，表示拥有魔法之后，结点 1 到结点 N 的最短距离。请精确到小数点后两位（四舍五入）。

## 样例 #1

### 样例输入 #1

```
5 2
0 34 24 0 0
34 0 10 12 0
24 10 0 16 20
0 12 16 0 30
0 0 20 30 0
```

### 样例输出 #1

```
22.00
```

## 提示

样例中，若对结点 1 与结点 3 之间的边、结点 3 与结点 5 之间的边各施展 1 次魔法，结点 1 到 结点 5 之间的最短距离就可以缩短至 22。

对于全部数据，保证 1 \leq N \leq 50，0 \leq M \leq 10，0 \leq adj_{i,j} \leq 30000，结点 1 到结点 N 之间至少存在一条路径。

其中：

- 至少 50% 的数据，M = 0。
- 至少 20% 的数据，1 \le N \leq 20。
- 至少 40% 的数据，结点 1 到结点 N 之间有且仅有一条简单路径。

---

# 树上的结点

## 题目描述

给定 N 个结点的一棵树。结点编号 1 \sim N，其中结点 1 为这棵树的根结点。每个结点还有一个特定的权值 w_i。

现在，请对于树上的每一个结点，计算以它为根的子树中一共有多少个权值比它大的结点。

注意：结点 j 在以结点 i 为根的子树中，当且仅当 i 是 j的祖先结点，或特殊地 j = i。

## 输入格式

第一行包含一个正整数 N，表示树的大小。

接下来 N 行，每行一个正整数 w_i，依次表示每一个结点的权值。

最后 N - 1行，每行一个正整数，依次表示结点 2 \sim N 的父亲结点的编号。

## 输出格式

共 N 行，每行一个非负整数，依次表示以结点 1 \sim N 为根的子树中，一共有多少个结点的权值比子根的权值要大。

## 样例 #1

### 样例输入 #1

```
5
80
84
68
71
95
1
1
2
3
```

### 样例输出 #1

```
2
0
1
0
0
```

## 提示

样例如图所示

[![jSdgDs.png](https://s1.ax1x.com/2022/06/21/jSdgDs.png)](https://imgtu.com/i/jSdgDs)

对于全部数据，保证 1 \le N \le 10^5，1 \le w_i \le 10^9。

各测试点的数据规模具体如下：

| 编号 | N | 编号 | N | 编号 | N |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | 5 | 5 | 2500 | 9 | 80000 |
| 2 | 30 | 6 | 8000 | 10 | 10^5 |
| 3 | 200 | 7 | 20000 |  |  |
| 4 | 1000 | 8 | 50000 |  |  |